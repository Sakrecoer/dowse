#!/usr/bin/env zsh
#
# Copyright (C) 2012-2016 Dyne.org Foundation
#
# Designed, written and maintained by Denis Roio <jaromil@dyne.org>
#
# This source code is free software; you can redistribute it
# and/or modify it under the terms of the GNU Public License
# as published by the Free Software Foundation; either
# version 3 of the License, or (at your option) any later
# version.
#
# This source code is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR
# PURPOSE.  Please refer to the GNU Public License for more
# details.
#
# You should have received a copy of the GNU Public License
# along with this source code; if not, write to: Free
# Software Foundation, Inc., 675 Mass Ave, Cambridge, MA
# 02139, USA.

# Keep sure that PATH is correct
source /etc/profile

source /etc/dowse/dir
export R=${DOWSE_DIR:-/opt/dowse}

[[ -r $R ]] || {
    error "Dowse is not installed in: $R"
    error "export DOWSE_DIR if installed on a different path"
    return 1
}

source ${R}/env

if [[ $dowse_loaded = 1 ]]; then
    act "Dowse CLI reloaded ::1::" $dowse_version
    RPROMPT=Dowse
else
    notice "Dowse CLI ::1:: - local area network rabdomancy" $dowse_version
    dowse_loaded=1
    RPROMPT=Dowse
fi

[[ $QUIET = 1 ]] || {
    cat <<EOF

 Copyright (C) 2012-2016 Dyne.org Foundation, License GNU GPL v3+
 This is free software: you are free to change and redistribute it
 For more informations see http://www.dyne.org/software/dowse

EOF
}

# TODO: using first argument here breaks ~/.zshrc auto-load

act "checking requirements to run dowse..."

[[ "$address" = "" ]] && {
    error "Invalid config file"
    zdump
    return 1
}

mkdir -p /run/dowse/conf
chown -R dowse:dowse /run/dowse/

_verbose "Dowse command: ::1 commands::" "$*"
_verbose "Caller: uid[::1 uid::], gid[::2 gid::], tty[::3 tty::]." \
         $dowse_uid $dowse_gid $TTY

act "daemons running as user and group $dowse_uid:$dowse_gid"

act "initialise things database"
#dbname="${address}_${wan}_${dowse_net//\//_}"
#db[things]="things_${dbname//./_}"
db[things]="things"
func "$db[things]"

# the global index of things database, path to it
# see: dowse/build/db/thing.idx
thingidx=$R/db/thing.idx
eventidx=$R/db/event.idx
parameteridx=$R/db/parameter.idx
constraintidx=$R/db/constraint.idx

act "all requirements in place"

fn dowse-running
# }}}



# {{{ MAIN

# Here is most of the hard-coded logic of dowse when starting up
# eventually some of this need to interact, acknowledge or even
# be moved into modules, depending from future developments.
# Meanwhile, special care is taken to keep this readable and
# transparent (avoid wrapping when possible), documenting choices
# with references.
dowse-start() {
    fn dowse-start
    # freq=($R/conf/settings $R/conf/network)
    # ckreq || return $?

	pid_path="/run/dowse/supervisord.pid"
	if [[ -f $pid_path ]]; then
		PID=$(cat $pid_path)
		# Check if dowse has already been started
		if [[ -d /proc/$PID ]]; then
			warn "Dowse is already running"
			return 1
		fi
	fi

	check_conflicts
	if [[ "$pids" != "" ]]; then
		if [[ "$DOWSE_KILL_CONFLICTS" == "1" ]]; then
			kill -9 $pids
			sleep 0.5
			check_conflicts
			if [[ "$pids" != "" ]]; then
				warn "The following programs could not be stopped: \
$conflicting_programs
Please manually stop them, as they're probably running under a supervisord"
				return 1
			else
				notice "Conflicting programs have been stopped"
			fi
		else
			warn "The following conflicting_programs are running: \
$conflicting_programs
Please close these programs before running Dowse or
set environment variable DOWSE_KILL_CONFLICTS to 1.
E.g.: DOWSE_KILL_CONFLICTS=1 ./start.sh"
			return 1
		fi
	fi
    notice "Starting Dowse"

    [[ "$firewall" = "yes" ]] && {

        # ebtables-stop
        iptables-stop

        loopback-on

        iptables-start

        iptables-base-protection

        if loopback-only; then
            act "dry run on localhost only"
        else
            loopback-isolate

			act "flushing arp cache"
			ip -s -s neigh flush all
            act "set up $interface interface with ip $address"
			ip addr add ${address}/${dowse_net[(ws:/:)2]} dev $interface
			ip link set $interface up

            [[ "$wan" = "" ]] || {
                act "set $wan as default gateway"
				ip route add default via $wan
            }

            act "setup snat trasversal"
            iptables-snat-on

            # make sure the dowse host uses his own dns
			[[ -r /etc/resolv.conf.dowse-backup ]] ||
				# this is problematic, we cannot sup mv or cat or tee
				# so perhaps take another approach: fw rule to redirect
				# all traffic to configured dns to our own until is up?
				mv /etc/resolv.conf /etc/resolv.conf.dowse-backup

            cat <<EOF > /etc/resolv.conf
nameserver $address
domain $lan
search $lan
EOF
        fi
    }

	echo "$address $lan" >> /etc/hosts

	notice "Starting all daemons in Dowse"

	supervisord -c $R/supervisord.conf

	# iptables-restore-things need redis to be running
	until [[ `supervisorctl -c $R/supervisord.conf status redis \
		| tr -s " " | cut -d" " -f 2` == "RUNNING" ]] {
		sleep 1
	}
	# Restore tables for all things enabled or disabled in redis storage
	iptables-restore-things

	redis-storage-setup

    notice "Dowse succesfully started" # , web interface up on:"
    # act "http://${address}:8500/"

}

dowse-stop() {
    fn dowse-stop

	notice "Stopping all daemons in Dowse"

	supervisorctl -c $R/supervisord.conf shutdown

	PID=$(cat /run/dowse/supervisord.pid)
	# Wait until supervisord has stopped all processes
	while [[ ( -d /proc/$PID ) && ( -z `grep zombie /proc/$PID/status` ) ]]; do
		sleep 0.5
	done

    # for m in `dowse-module-list`; do
    #     dowse-module-load $m || continue
    #     dowse-module-stop
    # done

    # remove the layer 2 firewall rules
    # ebtables-stop

    # remove the layer 3 firewall rules
    iptables-snat-off
    iptables-stop

	bridge_cleanup

    # restore backup if present
    [[ -r /etc/resolv.conf.dowse-backup ]] &&  {
        mv /etc/resolv.conf.dowse-backup /etc/resolv.conf
    }

	sed -i "/$address $lan/d" /etc/hosts

    notice "Dowse has stopped running."

}

# dowse-parse-leases() {
#     awk '
# BEGIN { c=0 }
# {
#   mac[c]=$2
#   ip[c]=$3
#   if($4=="*") host[c]="anonymous"; else host[c]=$4
# zx  c++
# }
# END {
#   printf "mac=("; for(i=0;i<c;i++) { printf "%s ", mac[i] }; printf ")\n"
#   printf "ip=("; for(i=0;i<c;i++) { printf "%s ", ip[i] }; printf ")\n"
#   printf "host=("; for(i=0;i<c;i++) { printf "%s ", host[i] }; printf ")\n"
# }' $H/run/leases
# }

dowse-dump() {
    fn dowse-dump

    notice "Dumping variables in Redis"
    act "Runtime:"
    print - "KEYS *" | redis runtime | sort
    act "Storage:"
    print - "KEYS *" | redis storage | sort
    act "Dynamic:"
    print - "KEYS *" | redis dynamic | sort
}

dowse-status() {
    fn dowse-status $*
    req=(sql)
    freq=($H/run/things.db)
    ckreq || return $?

    arg="$1"
    if [[ "$arg" = "" ]]; then
        minago=`date  "+%H:%M:%S" -d '1 day ago'`
        now=`date  "+%H:%M:%S"`
        notice "List things found online"
#        for res in "${(f)$(print - "SELECT * from found WHERE strftime('%H:%M:%S', last) between '$minago' and '$now';" | $sql -batch $H/run/things.db)}"; do
        for res in "${(f)$(print - "SELECT * from found;" | $sql $db[things])}"; do
            [[ "$res" = "" ]] && continue
            local -A _obj
            _obj=( $(print - $res | sql_idx_parse $R/db/thing.idx) )

            notice "$_obj[hostname] (${_obj[os]//_/ })"
            act "$_obj[last]"
            act "$_obj[macaddr] $_obj[ip4]"
            act "$_obj[iface] $_obj[state]"
        done

    else

        act "Search '$arg' among things found"
        for res in "${(f)$(sql_search $R/db/thing.idx found "$arg")}"; do
            [[ "$res" = "" ]] && continue
            local -A _obj
            _obj=( $(print - $res | sql_idx_parse $R/db/thing.idx) )
            notice "$_obj[hostname] (${_obj[os]//_/ })"
            act "$_obj[last]"
            act "$_obj[macaddr] $_obj[ip4]"
            act "$_obj[iface] $_obj[state]"
        done

    fi
    return 0
}

dowse-npm() {
	fn dowse-npm $*
	freq=($R/nodejs/node_dir/bin)
	ckreq || return $?

	NODE_PATH="$R/nodejs/node_dir/lib/node_modules:$R/node-red/node_modules" \
			 $R/nodejs/node_dir/bin/node \
			 $R/nodejs/node_dir/lib/node_modules/npm/bin/npm-cli.js $*
	return $?
}


# }}}

